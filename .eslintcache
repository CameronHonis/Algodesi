[{"/Users/kevin/algoDesi/src/index.tsx":"1","/Users/kevin/algoDesi/src/App.tsx":"2","/Users/kevin/algoDesi/src/models/BST.tsx":"3","/Users/kevin/algoDesi/src/Window.tsx":"4","/Users/kevin/algoDesi/src/models/V2.tsx":"5","/Users/kevin/algoDesi/src/models/DS.tsx":"6","/Users/kevin/algoDesi/src/models/Node.tsx":"7","/Users/kevin/algoDesi/src/Helpers.ts":"8","/Users/kevin/algoDesi/src/components/SelectionBar.tsx":"9","/Users/kevin/algoDesi/src/components/ItemSelection.tsx":"10","/Users/kevin/algoDesi/src/models/NodePhysics.tsx":"11","/Users/kevin/algoDesi/src/models/M2.tsx":"12","/Users/kevin/algoDesi/src/components/EdgeComp.tsx":"13","/Users/kevin/algoDesi/src/components/NodeComp.tsx":"14"},{"size":734,"mtime":1611806720657,"results":"15","hashOfConfig":"16"},{"size":1849,"mtime":1611806720654,"results":"17","hashOfConfig":"16"},{"size":26973,"mtime":1611806720658,"results":"18","hashOfConfig":"16"},{"size":16897,"mtime":1611806816529,"results":"19","hashOfConfig":"16"},{"size":6493,"mtime":1611806720660,"results":"20","hashOfConfig":"16"},{"size":165,"mtime":1611806720658,"results":"21","hashOfConfig":"16"},{"size":8871,"mtime":1611806720659,"results":"22","hashOfConfig":"16"},{"size":4011,"mtime":1611806720655,"results":"23","hashOfConfig":"16"},{"size":6675,"mtime":1612157078022,"results":"24","hashOfConfig":"16"},{"size":1619,"mtime":1612162017060,"results":"25","hashOfConfig":"16"},{"size":4793,"mtime":1611806720659,"results":"26","hashOfConfig":"16"},{"size":4135,"mtime":1611806720659,"results":"27","hashOfConfig":"16"},{"size":875,"mtime":1611806720657,"results":"28","hashOfConfig":"16"},{"size":1694,"mtime":1611806720657,"results":"29","hashOfConfig":"16"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},"4rpdta",{"filePath":"33","messages":"34","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35","usedDeprecatedRules":"32"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40","usedDeprecatedRules":"32"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"49","usedDeprecatedRules":"32"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},"/Users/kevin/algoDesi/src/index.tsx",[],["62","63"],"/Users/kevin/algoDesi/src/App.tsx",["64","65","66"],"import React, { useEffect } from \"react\";\nimport { BST } from \"./models/BST\";\n\nimport { DS } from \"./models/DS\";\nimport { V2 } from \"./models/V2\";\nimport { Window } from \"./Window\";\n\n\nexport interface Refs {\n  keysDown: Set<string>;\n}\n\nexport const initRefs: Refs = {\n  keysDown: new Set(),\n}\n\nexport interface State {\n  window: {\n    components: DS[];\n  }\n}\n\nexport const initState: State = {\n  window: {\n    components: []\n    //   new BST([1,2,3], new V2(0, 0)),\n    //   new BST([4,5,6], new V2(5,0))\n    // ]\n  },\n}\n\nexport interface AppContextType {\n  refs: Refs;\n  state: State;\n  setState: React.Dispatch<React.SetStateAction<State>>;\n}\n\nexport const AppContext = React.createContext<AppContextType>({refs: initRefs, state: initState, setState: () => {}});\n\nexport const App: React.FC = () => {\n  const refs = React.useRef<Refs>(initRefs);\n  const [ state, setState ] = React.useState<State>(initState);\n\n  const keysUpdated = () => {\n    if (refs.current.keysDown.has(\"q\") || refs.current.keysDown.has(\"Q\")) {\n      if (refs.current.keysDown.has(\"Shift\") || refs.current.keysDown.has(\"Ctrl\")) {\n        console.log(\"appState: \", state)\n        console.log(\"appRefs: \", refs.current)\n      }\n      refs.current.keysDown.delete(\"q\");\n      refs.current.keysDown.delete(\"Q\");\n      refs.current.keysDown.delete(\"Shift\");\n      refs.current.keysDown.delete(\"Ctrl\");\n      debugger;\n    }\n  }\n\n  const setKeyRefs = () => {\n\n  }\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", e => {\n      refs.current.keysDown.add(e.key);\n      keysUpdated();\n    })\n    document.addEventListener(\"keyup\", e => {\n      refs.current.keysDown.delete(e.key);\n      keysUpdated();\n    })\n  }, []); //eslint-disable-line\n  return (\n    <div className=\"App\">\n      <AppContext.Provider value={{refs: refs.current, state, setState}}>\n        <Window />\n      </AppContext.Provider>\n    </div>\n  );\n}","/Users/kevin/algoDesi/src/models/BST.tsx",[],"/Users/kevin/algoDesi/src/Window.tsx",["67","68"],"import React from \"react\";\nimport { BSTComp } from \"./components/BSTComp\";\nimport { AppContext, AppContextType } from \"./App\"\nimport { V2 } from \"./models/V2\";\nimport { DS } from \"./models/DS\";\nimport { BST } from \"./models/BST\";\nimport { Node } from \"./models/Node\";\nimport { DSPhysics } from \"./models/DSPhysics\";\nimport { NodePhysics } from \"./models/NodePhysics\";\nimport { M2 } from \"./models/M2\";\nimport Helpers from \"./Helpers\";\nimport { NodeComp } from \"./components/NodeComp\";\nimport { EdgeComp } from \"./components/EdgeComp\";\nimport SelectionBar from './components/SelectionBar'\n\nexport const MAX_WINDOW_SIZE: V2 = new V2(100, 50);\nexport const MIN_WINDOW_SIZE: V2 = new V2(5, 2.5);\nexport const MAX_INIT_WINDOW_SIZE: V2 = new V2(20, 20);\nexport const INIT_WINDOW_POS: V2 = new V2(0, 0);\n\nexport const POS_TWEEN_COEFF: number = .9;\nexport const POS_TWEEN_OFFSET: number = .001;\nexport const SIZE_TWEEN_COEFF: number = .15;\nexport const SIZE_TWEEN_OFFSET: number = .001;\nexport const WINDOW_TWEEN_CLOCK_MS: number = 10;\n\nexport const PHYSICS_CLOCK_MS: number = 20;\n\nexport const PRIORITIES_CLOCK_MS: number = 1000;\n\nconst Node0: Node = new Node(null, 0);\nconst BST0: BST = new BST(Node0);\nconst Node0Physics: NodePhysics = new NodePhysics(Node0, new V2(0, 0));\n\nconst Node1: Node = new Node(null, 1);\nBST0.insert(Node1);\nconst Node1Physics: NodePhysics = new NodePhysics(Node1, new V2(0, 1));\n\nexport interface Refs {\n  viewportSize: V2;\n  pos: V2;\n  size: V2;\n  targetPos: V2;\n  targetSize: V2;\n  isTweeningWindow: boolean;\n  posSizeTweenSynced: boolean;\n  debugElements: Partial<{\n    pos: React.MutableRefObject<HTMLParagraphElement>;\n    size: React.MutableRefObject<HTMLParagraphElement>;\n    targetPos: React.MutableRefObject<HTMLParagraphElement>;\n    targetSize: React.MutableRefObject<HTMLParagraphElement>;\n    synced: React.MutableRefObject<HTMLParagraphElement>;\n    physicsFreq: React.MutableRefObject<HTMLParagraphElement>;\n  }>;\n  nodeElements: {\n    [index: number]: React.MutableRefObject<HTMLDivElement>;\n  };\n  edgeElements: {\n    [index: string]: React.MutableRefObject<HTMLDivElement>;\n  }\n  physics: {\n    DSComps: {[index: number]: DSPhysics};\n    NodeComps: {[index: number]: NodePhysics};\n  };\n}\n\nconst initWindowSize: V2 = new V2(\n  20 * Math.min(window.innerWidth/window.innerHeight, 1),\n  20 * Math.min(window.innerHeight / window.innerWidth, 1)\n);\n\nexport const initRefs: Refs = {\n  viewportSize: new V2(window.innerWidth, window.innerHeight),\n  pos: INIT_WINDOW_POS,\n  size: initWindowSize,\n  targetPos: INIT_WINDOW_POS,\n  targetSize: initWindowSize,\n  isTweeningWindow: false,\n  posSizeTweenSynced: true,\n  debugElements: {\n    pos: React.createRef() as React.MutableRefObject<HTMLParagraphElement>,\n    size: React.createRef() as React.MutableRefObject<HTMLParagraphElement>,\n    targetPos: React.createRef() as React.MutableRefObject<HTMLParagraphElement>,\n    targetSize: React.createRef() as React.MutableRefObject<HTMLParagraphElement>,\n    synced: React.createRef() as React.MutableRefObject<HTMLParagraphElement>,\n    physicsFreq: React.createRef() as React.MutableRefObject<HTMLParagraphElement>,\n  },\n  nodeElements: {},\n  edgeElements: {},\n  physics: {\n    DSComps: {},\n    NodeComps: {0: Node0Physics, 1: Node1Physics},\n  },\n}\n\nexport enum RefsAction {\n  SET_SIZE,\n  SET_SIZE_POS,\n  SET_TARGET_POS,\n  SET_TARGET_SIZE,\n  SET_TWEEN_SYNCED,\n  SET_IS_TWEENING_WINDOW,\n  SET_VIEWPORT_SIZE,\n}\n\nexport interface State {\n  nodes: {\n    [index: number]: Node;\n  };\n}\n\nexport const initState: State = {\n  nodes: {\n    0: Node0,\n    1: Node1,\n  }\n}\n\nexport const Window: React.FC = () => {\n  let { state: appState, setState: setAppState, refs: appRefs } = React.useContext<AppContextType>(AppContext); //eslint-disable-line\n\n  const [ state, setState ] = React.useState<State>(initState); //eslint-disable-line\n\n  const { current: refs } = React.useRef(initRefs);\n  const setRefs = (action: RefsAction, arg: any): any => {\n    if (action === RefsAction.SET_SIZE && arg instanceof V2) {\n      refs.size = arg;\n      renderNodes();\n      if (refs.debugElements.size?.current) {\n        refs.debugElements.size.current.textContent = \"size: \" + refs.size.toString();\n      }\n    } else if (action === RefsAction.SET_SIZE_POS && arg && arg.pos instanceof V2 && arg.size instanceof V2) {\n      refs.pos = arg.pos;\n      refs.size = arg.size;\n      renderNodes();\n      if (refs.debugElements.pos?.current && refs.debugElements.size?.current) {\n        refs.debugElements.pos.current.textContent = \"pos: \" + refs.pos.toString();\n        refs.debugElements.size.current.textContent = \"size: \" + refs.size.toString();\n      }\n    } else if (action === RefsAction.SET_TARGET_POS && arg instanceof V2) {\n      refs.targetPos = arg;\n      initWindowTween();\n      if (refs.debugElements.targetPos?.current) {\n        refs.debugElements.targetPos.current.textContent = \"targetPos: \" + refs.targetPos.toString();\n      }\n    } else if (action === RefsAction.SET_TARGET_SIZE && arg instanceof V2) {\n      refs.targetSize = arg;\n      initWindowTween();\n      if (refs.debugElements.targetSize?.current) {\n        refs.debugElements.targetSize.current.textContent = \"targetSize: \" + refs.targetSize.toString();\n      }\n    } else if (action === RefsAction.SET_TWEEN_SYNCED && typeof arg === \"boolean\") {\n      refs.posSizeTweenSynced = arg;\n      if (refs.debugElements.synced?.current) {\n        refs.debugElements.synced.current.textContent = \"synced: \" + (refs.posSizeTweenSynced ? \"⬤\" : \"\");\n      }\n    } else if (action === RefsAction.SET_IS_TWEENING_WINDOW && typeof arg === \"boolean\") {\n      refs.isTweeningWindow = arg;\n    } else if (action === RefsAction.SET_VIEWPORT_SIZE && arg instanceof V2) {\n      if (refs.viewportSize.x === arg.x) {\n        const uncappedYSize: number = refs.targetSize.y * arg.y/refs.viewportSize.y;\n        const newYSize: number = Math.max(MIN_WINDOW_SIZE.y, Math.min(uncappedYSize, MAX_WINDOW_SIZE.y));\n        const ratio: number = refs.targetSize.x / uncappedYSize;\n        const newXSize: number = newYSize * ratio;\n        setRefs(RefsAction.SET_SIZE, refs.size.parallelProduct(newXSize / refs.targetSize.x, newYSize / refs.targetSize.y));\n        setRefs(RefsAction.SET_TARGET_SIZE, new V2(newXSize, newYSize));\n      } else {\n        const uncappedXSize: number = refs.targetSize.x * arg.x/refs.viewportSize.x;\n        const newXSize: number = Math.max(MIN_WINDOW_SIZE.x, Math.min(uncappedXSize, MAX_WINDOW_SIZE.x));\n        const ratio: number = uncappedXSize / refs.targetSize.y;\n        const newYSize: number = newXSize / ratio;\n        setRefs(RefsAction.SET_SIZE, refs.size.parallelProduct(newXSize / refs.targetSize.x, newYSize / refs.targetSize.y));\n        setRefs(RefsAction.SET_TARGET_SIZE, new V2(newXSize, newYSize));\n      }\n      refs.viewportSize = arg;\n    }\n  }\n\n  React.useEffect(() => {\n    document.addEventListener(\"wheel\", e => {\n      const deltaSize: V2 = new V2(e.deltaY/1000*refs.targetSize.x, e.deltaY/1000*refs.targetSize.y);\n      const mousePos: V2 = refs.targetPos.add(refs.targetSize.parallelProduct(.5 - e.clientX/window.innerWidth, e.clientY/window.innerHeight - .5));\n      const deltaPos: V2 = mousePos.add(refs.targetPos.scale(-1)).parallelProduct(deltaSize.x/refs.targetSize.x, deltaSize.y/refs.targetSize.y);\n      let minCoeff: number = 1;\n      if (refs.targetSize.x + deltaSize.x > MAX_WINDOW_SIZE.x) {\n        minCoeff = Math.min(minCoeff, (MAX_WINDOW_SIZE.x - refs.targetSize.x) / deltaSize.x);\n      }\n      if (refs.targetSize.x + deltaSize.x < MIN_WINDOW_SIZE.x) {\n        minCoeff = Math.min(minCoeff, -(refs.targetSize.x - MIN_WINDOW_SIZE.x) / deltaSize.x);\n      }\n      if (refs.targetSize.y + deltaSize.y > MAX_WINDOW_SIZE.y) {\n        minCoeff = Math.min(minCoeff, (MAX_WINDOW_SIZE.y - refs.targetSize.y) / deltaSize.y);\n      }\n      if (refs.targetSize.y + deltaSize.y < MIN_WINDOW_SIZE.y) {\n        minCoeff = Math.min(minCoeff, -(MIN_WINDOW_SIZE.y - refs.targetSize.y) / deltaSize.y);\n      }\n      setRefs(RefsAction.SET_TARGET_SIZE, refs.targetSize.add(deltaSize.scale(minCoeff)));\n      setRefs(RefsAction.SET_TARGET_POS, refs.targetPos.add(deltaPos.scale(minCoeff)));\n    });\n    document.addEventListener(\"mousemove\", e => {\n      if (appRefs.keysDown.has(1) || appRefs.keysDown.has(\" \")) {\n        setRefs(RefsAction.SET_TWEEN_SYNCED, false);\n        setRefs(RefsAction.SET_TARGET_POS, refs.targetPos.add(\n          -e.movementX / window.innerWidth * refs.targetSize.x,\n          e.movementY / window.innerHeight * refs.targetSize.y\n        ));\n      }\n    });\n    window.addEventListener(\"resize\", () => {\n      if (Math.abs(refs.viewportSize.x - window.innerWidth) > 10 || Math.abs(refs.viewportSize.y - window.innerHeight) > 10) {\n        setRefs(RefsAction.SET_VIEWPORT_SIZE, new V2(window.innerWidth, window.innerHeight));\n      }\n    });\n    const prioritiesClock = () => {\n      const history: Set<NodePhysics> = new Set();\n      for (const nodeComp of Object.values(refs.physics.NodeComps)) {\n        const predPath: M2 = new M2(nodeComp.pos, nodeComp.pos.add(nodeComp.velo.scale(2)));\n        history.add(nodeComp);\n        for (const nodeComp2 of Object.values(refs.physics.NodeComps)) {\n          if (!history.has(nodeComp2)) {\n            nodeComp.setRelation(nodeComp2, predPath);\n          }\n        }\n      }\n      setTimeout(() => {\n        prioritiesClock();\n      }, PRIORITIES_CLOCK_MS);\n    }\n    prioritiesClock();\n    let lastPhysDebugUpdate: number = 0;\n    const physicsClock = (lastMiS: number) => {\n      //optimize all loops runtime O(n) to O(r) n = #nodes, r = #rendered nodes\n      let history: Set<NodePhysics> = new Set();\n      for (const nodeComp of Object.values(refs.physics.NodeComps)) {\n        nodeComp.accel = new V2(0, 0);\n      }\n      history = new Set();\n      for (const nodeComp of Object.values(refs.physics.NodeComps)) {\n        history.add(nodeComp);\n        for (const nodeComp2 of nodeComp.highPriorityRelations) {\n          if (!history.has(nodeComp2)) {\n            nodeComp.addForce(nodeComp2, refs.physics.NodeComps);\n          }\n        }\n      }\n      for (const nodeComp of Object.values(refs.physics.NodeComps)) {\n        nodeComp.addDrag();\n      }\n      history = new Set();\n      const currMiS: number = window.performance.now()\n      const dt: number = (currMiS - lastMiS) / 1000;\n      if (currMiS - lastPhysDebugUpdate > 100) {\n        if (refs.debugElements.physicsFreq?.current) {\n          lastPhysDebugUpdate = currMiS;\n          refs.debugElements.physicsFreq.current.textContent = \"physics: \" + Helpers.round(1/dt) + \"hz\";\n        }\n      }\n      for (const nodeComp of Object.values(refs.physics.NodeComps)) {\n        if (nodeComp.accel.magnitude() > 0) {\n          nodeComp.incrementPhysics(dt, refs.pos, refs.size);\n        }\n      }\n      renderNodes();\n      setTimeout(() => {\n        physicsClock(currMiS);\n      }, PHYSICS_CLOCK_MS);\n    }\n    physicsClock(window.performance.now());\n  }, []) //eslint-disable-line\n\n  const renderNodes = (): void => {\n    for (const [ nodeIdString, nodeElementRefs ] of Object.entries(refs.nodeElements)) {\n      const nodeId = parseInt(nodeIdString);\n      const nodePhysics: NodePhysics = refs.physics.NodeComps[nodeId];\n      if (!(nodeId in refs.physics.NodeComps)) { console.log(\"couldnt find node physics\"); continue; }\n      const nodeDiv: HTMLDivElement = nodeElementRefs.current;\n      const nodeSVG: SVGSVGElement | null = nodeDiv.querySelector(\"svg\");\n      const nodeP: HTMLParagraphElement | null = nodeDiv.querySelector(\"#node\" + nodeIdString + \"value\");\n      if (!nodeSVG || !nodeP) { continue; }\n      const nodePixPos: V2 = Helpers.toPixelPos(refs.pos, refs.size, nodePhysics.pos);\n      const nodePixSize: V2 = Helpers.toPixelSize(refs.size, new V2(1, 1));\n      nodeDiv.style.left = nodePixPos.x + \"px\";\n      nodeDiv.style.top = nodePixPos.y + \"px\";\n      nodeDiv.style.width = nodePixSize.x + \"px\";\n      nodeDiv.style.height = nodePixSize.y + \"px\";\n      nodeP.style.fontSize = window.innerWidth * .7 / refs.size.x + \"px\";\n      const node: Node = state.nodes[nodeId];\n      if (node) {\n        if (node.left && node.left.id in refs.physics.NodeComps) {\n          const leftNodePhysics: NodePhysics = refs.physics.NodeComps[node.left.id];\n          const edgeRef: React.MutableRefObject<HTMLDivElement> = refs.edgeElements[node.id + \"-\" + node.left.id];\n          if (edgeRef && edgeRef.current) {\n            new M2(nodePhysics.pos, leftNodePhysics.pos).fitDiv(edgeRef.current, refs.pos, refs.size, 10, 10);\n          }\n        }\n        if (node.right && node.right.id in refs.physics.NodeComps) {\n          const rightNodePhysics: NodePhysics = refs.physics.NodeComps[node.right.id];\n          const edgeRef: React.MutableRefObject<HTMLDivElement> = refs.edgeElements[node.id + \"-\" + node.right.id];\n          if (edgeRef && edgeRef.current) {\n            new M2(nodePhysics.pos, rightNodePhysics.pos).fitDiv(edgeRef.current, refs.pos, refs.size, 10, 10);\n          }\n        }\n      }\n      //annotations vvv\n      const posAnno: HTMLParagraphElement | null = document.querySelector(\"#node\" + nodeIdString + \"label1\");\n      if (posAnno) {\n        posAnno.style.left = nodePixPos.x + nodePixSize.x/2 + 5 + \"px\";\n        posAnno.style.top = nodePixPos.y - nodePixSize.y/2 + \"px\";\n        posAnno.textContent = \"pos: \" + refs.physics.NodeComps[nodeId].pos.toString(3);\n      }\n      const accelVec: HTMLDivElement | null = document.querySelector(\"#node\" + nodeIdString + \"vector1\");\n      if (accelVec) {\n        new M2(nodePhysics.pos, nodePhysics.pos.add(nodePhysics.accel)).fitDiv(accelVec, refs.pos, refs.size);\n      }\n    }\n  }\n\n  const initWindowTween = (): void => {\n    const windowTween = (): void => {\n      setRefs(RefsAction.SET_IS_TWEENING_WINDOW, true);\n      let [ newSize, sizeMet ] = refs.size.tween(refs.targetSize, SIZE_TWEEN_COEFF, SIZE_TWEEN_OFFSET*refs.targetSize.x);\n      let [ newPos, posMet ] = refs.pos.tween(refs.targetPos, POS_TWEEN_COEFF, POS_TWEEN_OFFSET*refs.targetSize.x);\n      if (refs.posSizeTweenSynced) {\n        let relSizeDiff: number = 1;\n        if (refs.size.add(refs.targetSize.scale(-1)).magnitude() !== 0) {\n          relSizeDiff = refs.size.add(newSize.scale(-1)).magnitude() / refs.size.add(refs.targetSize.scale(-1)).magnitude();\n        }\n        let relPosDiff: number = 1;\n        if (refs.pos.add(refs.targetPos.scale(-1)).magnitude() !== 0) {\n          relPosDiff = refs.pos.add(newPos.scale(-1)).magnitude() / refs.pos.add(refs.targetPos.scale(-1)).magnitude();\n        }\n        [ newSize, sizeMet ] = refs.size.tween(refs.targetSize, Math.min(relSizeDiff, relPosDiff, 1), 0);\n        [ newPos, posMet ] = refs.pos.tween(refs.targetPos, Math.min(relSizeDiff, relPosDiff, 1), 0);\n      }\n      setTimeout(() => {\n        setRefs(RefsAction.SET_SIZE_POS, {size: newSize, pos: newPos});\n        if (sizeMet && posMet) {\n          setRefs(RefsAction.SET_IS_TWEENING_WINDOW, false);\n          setRefs(RefsAction.SET_TWEEN_SYNCED, true);\n          return;\n        }\n        windowTween();\n      }, WINDOW_TWEEN_CLOCK_MS);\n    }\n    if (!refs.isTweeningWindow) {\n      windowTween();\n    }\n  }\n\n  const nodeComps: JSX.Element[] = [];\n  const edgeComps: JSX.Element[] = [];\n  for (let node of Object.values(state.nodes)) {\n    nodeComps.push(<NodeComp key={node.id} node={node} windowRefs={refs} setWindowRefs={setRefs} />);\n    if (node.left) {\n      edgeComps.push(<EdgeComp key={node.id + \"-\" + node.left.id} node1={node} node2={node.left} windowRefs={refs} setWindowRefs={setRefs} />);\n    }\n    if (node.right) {\n      edgeComps.push(<EdgeComp key={node.id + \"-\" + node.right.id} node1={node} node2={node.right} windowRefs={refs} setWindowRefs={setRefs} />);\n    }\n  }\n  return(\n    <div \n      id=\"window\"\n    >\n      <div id=\"debuggerLabels\">\n        <p ref={refs.debugElements.pos} className=\"noselect\" style={{position: \"absolute\"}} >{\"pos: \" + refs.pos.toString()}</p>\n        <p ref={refs.debugElements.targetPos} className=\"noselect\" style={{position: \"absolute\", top: \"20px\"}} >{\"targetPos: \" + refs.targetPos.toString()}</p>\n        <p ref={refs.debugElements.size} className=\"noselect\" style={{position: \"absolute\", top: \"40px\"}} >{\"size: \" + refs.size.toString()}</p>\n        <p ref={refs.debugElements.targetSize} className=\"noselect\" style={{position: \"absolute\", top: \"60px\"}} >{\"targetSize: \" + refs.targetSize.toString()}</p>\n        <p ref={refs.debugElements.synced} className=\"noselect\" style={{position: \"absolute\", top: \"80px\"}} >{\"synced: ⬤\"}</p>\n        <p ref={refs.debugElements.physicsFreq} className=\"noselect\" style={{position: \"absolute\", top: \"100px\"}} >physics: </p>\n      </div>\n      <div id=\"nodeComps\">\n        {nodeComps}\n      </div>\n      <div id=\"edgeComps\">\n        {edgeComps}\n      </div>\n      <SelectionBar/>\n    </div>\n  )\n}","/Users/kevin/algoDesi/src/models/V2.tsx",[],"/Users/kevin/algoDesi/src/models/DS.tsx",[],"/Users/kevin/algoDesi/src/models/Node.tsx",[],"/Users/kevin/algoDesi/src/Helpers.ts",["69"],"import { V2 } from \"./models/V2\";\nimport { RefsAction } from \"./Window\";\n\nexport default class Helpers {\n  static binarySearch(callback: (val: any) => number, arr: any[]): [number, boolean]\n  static binarySearch(value: number, arr: number[]): [number, boolean]\n  static binarySearch(value: string, arr: string[]): [number, boolean]\n  static binarySearch(value: boolean, arr: boolean[]): [number, boolean]\n  static binarySearch(value: any, arr: any[]): [number, boolean]\n  static binarySearch(...arg: any): [idx: number, match: boolean] {\n    let arr: any[], comparator: (val: any) => number | undefined;\n    if (typeof arg[0] === \"function\" && arg[1] instanceof Array) {\n      comparator = arg[0];\n      arr = arg[1];\n    } else if ((typeof arg[0] === \"number\" || typeof arg[0] === \"string\" || typeof arg[0] === \"boolean\")\n    && arg[1] instanceof Array && typeof arg[0] === typeof arg[1][0]) {\n      comparator = (val: number | string | boolean) => {\n        if (val < arg[0]) {\n          return -1;\n        } else if (val > arg[0]) {\n          return 1;\n        } else {\n          return 0;\n        }\n      }\n      arr = arg[1];\n    } else if (typeof arg[0][\"compare\"] === \"function\" && arg[0].constructor.name === arg[1][0].constructor.name) {\n      comparator = arg[0][\"compare\"];\n      arr = arg[1];\n    } else {\n      let errorStr: string = \"Unhandled parameter types: \" + arg[0].constructor.name;\n      for (let i = 1; i < arg.length; ++i) {\n        errorStr += \", \" + arg[i].constructor.name;\n      }\n      errorStr += \" for Helpers.binarySearch\";\n      throw new Error(errorStr);\n    }\n    if (arr.length === 0) {\n      return [0, false];\n    }\n    let leftPointer: number = 0;\n    let rightPointer: number = arr.length - 1;\n    let foundMatch: boolean = false;\n    while (leftPointer <= rightPointer) {\n      const mid: number = Math.floor((leftPointer + rightPointer) / 2);\n      if (comparator(arr[mid]) === 1) {\n        rightPointer = mid - 1;\n      } else if (comparator(arr[mid]) === -1) {\n        leftPointer = mid + 1;\n      } else {\n        rightPointer = mid - 1;\n        leftPointer = mid;\n        foundMatch = true;\n      }\n    }\n    return [rightPointer + 1, foundMatch];\n  }\n\n  static round(num: number, sigFigs: number = 4, sciNotation: boolean = false): string {\n    sigFigs = Math.max(sigFigs, 1);\n    const coeff: number = Math.pow(10, sigFigs-1);\n    const pow10: number = num ? -Math.ceil(Math.log10(Math.abs(1/num))) : 0;\n    const rounded: number = Math.round(coeff*Math.pow(10, -pow10)*num)/coeff;\n    if (sciNotation) {\n      return rounded + (pow10 ? \"E\" + pow10 : \"\");\n    } else {\n      const xStrSize: number = Math.max(\n        sigFigs + pow10 + Math.max(-Math.sign(rounded),0),\n        sigFigs - pow10 + 1 + Math.max(-Math.sign(rounded),0),\n        sigFigs + 1);\n      return (rounded*Math.pow(10, pow10)).toString().slice(0, xStrSize);\n    }\n  }\n\n  static toPixelPos(screenPos: V2, screenSize: V2, pos: V2): V2 { // converts pos from appState dimensions into DOM pix dimension\n    return new V2(\n      (pos.x - screenPos.x + screenSize.x/2) / screenSize.x * window.innerWidth,\n      (1 - (pos.y - screenPos.y + screenSize.y/2) / screenSize.y) * window.innerHeight\n    );\n  }\n\n  static toScreenPos(screenPos: V2, screenSize: V2, pos: V2): V2 { // converts pos from DOM pix dimensions into appState dimension\n    return new V2(\n      pos.x / window.innerWidth * screenSize.x - screenSize.x/2 + screenPos.x,\n      (1 - pos.y / window.innerHeight) * screenSize.y - screenSize.y/2 + screenPos.y\n    );\n  }\n\n  static toPixelSize(screenSize: V2, size: V2): V2 { // converts appState dimension to DOM pix dimension\n    return new V2(\n      size.x / screenSize.x * window.innerWidth,\n      size.y / screenSize.y * window.innerHeight\n    );\n  }\n\n  static toScreenSize(screenSize: V2, size: V2): V2 { // converts DOM pix dimension to appState dimension\n    return new V2(\n      size.x / window.innerWidth * screenSize.x,\n      size.y / window.innerHeight * screenSize.y\n    );\n  }\n}","/Users/kevin/algoDesi/src/components/SelectionBar.tsx",["70"],"/Users/kevin/algoDesi/src/components/ItemSelection.tsx",[],"/Users/kevin/algoDesi/src/models/NodePhysics.tsx",[],"/Users/kevin/algoDesi/src/models/M2.tsx",[],"/Users/kevin/algoDesi/src/components/EdgeComp.tsx",[],"/Users/kevin/algoDesi/src/components/NodeComp.tsx",[],{"ruleId":"71","replacedBy":"72"},{"ruleId":"73","replacedBy":"74"},{"ruleId":"75","severity":1,"message":"76","line":2,"column":10,"nodeType":"77","messageId":"78","endLine":2,"endColumn":13},{"ruleId":"75","severity":1,"message":"79","line":5,"column":10,"nodeType":"77","messageId":"78","endLine":5,"endColumn":12},{"ruleId":"75","severity":1,"message":"80","line":58,"column":9,"nodeType":"77","messageId":"78","endLine":58,"endColumn":19},{"ruleId":"75","severity":1,"message":"81","line":2,"column":10,"nodeType":"77","messageId":"78","endLine":2,"endColumn":17},{"ruleId":"75","severity":1,"message":"82","line":5,"column":10,"nodeType":"77","messageId":"78","endLine":5,"endColumn":12},{"ruleId":"75","severity":1,"message":"83","line":2,"column":10,"nodeType":"77","messageId":"78","endLine":2,"endColumn":20},{"ruleId":"84","severity":1,"message":"85","line":253,"column":6,"nodeType":"86","endLine":253,"endColumn":8,"suggestions":"87"},"no-native-reassign",["88"],"no-negated-in-lhs",["89"],"@typescript-eslint/no-unused-vars","'BST' is defined but never used.","Identifier","unusedVar","'V2' is defined but never used.","'setKeyRefs' is assigned a value but never used.","'BSTComp' is defined but never used.","'DS' is defined but never used.","'RefsAction' is defined but never used.","react-hooks/exhaustive-deps","React Hook React.useEffect has a missing dependency: 'setBarRefs'. Either include it or remove the dependency array.","ArrayExpression",["90"],"no-global-assign","no-unsafe-negation",{"desc":"91","fix":"92"},"Update the dependencies array to be: [setBarRefs]",{"range":"93","text":"94"},[5888,5890],"[setBarRefs]"]